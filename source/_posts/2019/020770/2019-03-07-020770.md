---
layout: post
title:  "sql优化总结"
date:   2019-03-07 03:32:36  +0800
source:  ""
fileName:  "020770"
lang:  "zh_CN"
published: true
categories: []
tags: []

---

1. 查询语句中不要使用*；
2. 尽量减少子查询，使用关联查询（left join, right join, inner join）代替；
3. 减少使用IN或者NOT IN，使用exists,not exists或者关联查询语句代替；
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，尽量用union或者union all代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)；
5. 合理的增加冗余的字段（减少表的关联查询）；
6. 增加中间表进行优化（这个主要是在统计报表的场景，后台开定时任务将数据先统计好，尽量不要在查询的时候去统计）；
7. 建表的时候能使用数字类型的字段就使用数字类型（type,status…），数字类型的字段作为条件查询比字符串快。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了；
8. 那些可以过滤掉最大数量记录的条件必须写在where字句的最末尾；
9. 尽量避免在where字句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；
10. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描；
11. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描；
12. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描；
13. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致；
14. 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差；
15. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要；
16. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些；
17. 使用like关键字模糊查询时，% 放在前面索引不起作用，只有“%”不在第一个位置，索引才会生效（like ‘%文’–索引不起作用）；
18. 对查询进行优化，应尽量避免全表扫描，首先应考虑在where以及order by涉及的列上建立索引。