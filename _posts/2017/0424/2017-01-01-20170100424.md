---
layout: post
title:  "JVM 优化问题 » java面试题"
title2:  "JVM 优化问题 » java面试题"
date:   2017-01-01 23:42:04  +0800
source:  "https://www.jfox.info/JVM-you-hua-wen-ti.html"
fileName:  "0424"
lang:  "zh_CN"
published: true
permalink: "2017/JVM-you-hua-wen-ti.html"
---



### jvm 优化问题

JVM堆内存分为2块：Permanent Space 和 Heap Space。

    Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。
Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。

我们知道Java和C++的区别主要是，Java不需要像c++那样，由程序员主动的释放内存。而是由JVM里的GC(GarbageCollection)来，在适当的时候替我们释放内存。JVM GC调整优化的内部工作，即JVM GC的算法有很多种,如：标记清除收集器，压缩收集器，分代收集器等等。现在比较常用的是分代收集（也是SUNVM使用的），即将内存分为几个区域，将不同生命周期的对象放在不同区域里（新的对象会先生成在Youngarea，在几次ＧＣ以后，如过没有收集到，就会逐渐升级到Tenuredarea）。在JVM GC收集的时候，频繁收集生命周期短的区域(Youngarea)，因为这个区域内的对象生命周期比较短，GC效率也会比较高。而比较少的收集生命周期比较长的区域(OldareaorTenuredarea)，以及基本不收集的永久区(Permarea)。

优化堆大小的设置。如果堆设置较大，可能导致 GC 的次数变少，但每次 GC 所花的时间很长，从而导致系统的处理能力抖动很大。此外如果堆设置过大，会占用过多的内存，使内存资源耗尽，从而会频繁的进行 IO 操作来使用虚拟内存。 如果堆设置较小，可能导致 GC 变的频繁，但每次 GC 所花的时间不会太长，每次 GC 对系统的性能影响相对也会小些。但是如果堆设置过小， 会使得对象可分配空间变小，从而会频繁的 GC 来释放内存空间，而每次 GC，都会耗用一定的系统资源。因此，要通过试验和监控数据，设法使的我们所设置的堆大小能够使得系统运行最优化。

众所周知，Java是从C++的基础上发展而来的，而C++程序的很大的一个问题就是内存泄露难以解决，尽管Java的JVM有一套自己的垃圾回收机制来回收内存，在许多情况下并不需要java程序开发人员操太多的心，但也是存在泄露问题的，只是比C++小一点。比如说，程序中存在被引用但无用的对象：程序引用了该对象，但后续不会或者不能再使用它，那么它占用的内存空间就浪费了。

我们先来看看GC是如何工作的:监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，当该对象不再被引用时，释放对象(GC本文的重点，不做过多阐述)。很多Java程序员过分依赖GC，但问题的关键是无论JVM的垃圾回收机制做得多好，内存总归是有限的资源，因此就算GC会为我们完成了大部分的垃圾回收，但适当地注意编码过程中的内存优化还是很必要的。这样可以有效的减少GC次数，同时提升内存利用率，最大限度地提高程序的效率。

优化程序代码：

1.尽早释放无用对象的引用(XX = null;)   
2.谨慎使用集合数据类型，如数组，树，图，链表等数据结构，这些数据结构对GC来说回收更复杂。
3.避免显式申请数组空间，不得不显式申请时，尽量准确估计其合理值。
4.尽量避免在类的默认构造器中创建、初始化大量的对象，防止在调用其自类的构造器时造成不必要的内存资源浪费
5.尽量避免强制系统做垃圾内存的回收，增长系统做垃圾回收的最终时间
6.尽量做远程方法调用类应用开发时使用瞬间值变量，除非远程调用端需要获取该瞬间值变量的值。
7.尽量在合适的场景下使用对象池技术以提高系统性能

总体而言，Java虚拟机的内存优化应从两方面着手：Java虚拟机和Java应用程序。前者指根据应用程序的设计通过虚拟机参数控制虚拟机逻辑内存分区的大小以使虚拟机的内存与程序对内存的需求相得益彰；后者指优化程序算法，降低GC负担，提高GC回收成功率。
